#!/usr/bin/env python2.7

import argparse
import collections
import os
import re
import subprocess
import sys

template = '''
builddir = obj
rule cc
    command     = {cc} -x c {cppflags} {cflags} -MMD -MF $out.d -c $in -o $out
    depfile     = $out.d
    deps        = gcc
    description = compile $out
rule cxx
    command     = {cxx} -x c++ {cppflags} {cxxflags} -MMD -MF $out.d -c $in -o $out
    depfile     = $out.d
    deps        = gcc
    description = compile $out
rule link_cc
    command     = {cc} {ldflags} $in -o $out
    description = link $out
rule link_cxx
    command     = {cxx} -lc++ {ldflags} $in -o $out
    description = link $out
rule run
    command     = ./$in > $out
'''

parser = argparse.ArgumentParser(description='ob, opinionated builder')
for mode in ['debug', 'release', 'ASAN', 'TSAN']:
    parser.add_argument('-'+mode.upper()[0], '--'+mode.lower(),
                        action='store_const', dest='mode', const=mode.lower(), help=mode)
args,ninja_args = parser.parse_known_args()

cc  = os.getenv('CC',  'clang')
cxx = os.getenv('CXX', cc)
is_clang = 'clang' in cc and 'clang' in cxx

cppflags = [ '-fPIC' ]
cflags   = ['-std=c11']
cxxflags = ['-std=c++14', '-fno-exceptions', '-fno-rtti']
ldflags  = []

if is_clang:
    cppflags.append('-fcolor-diagnostics')
if args.mode != 'debug':
    cppflags.append('-Os')
if args.mode != 'release':
    cppflags.extend(['-g', '-Werror'])
    cppflags.extend(['-Weverything', '-Wno-padded'] if is_clang else ['-Wall', '-Wextra'])
if args.mode == 'release':
    cppflags.append('-DNDEBUG')
if args.mode == 'asan':
    cppflags.append('-fsanitize=address,undefined')
    ldflags .append('-fsanitize=address,undefined')
if args.mode == 'tsan':
    cppflags.append('-fsanitize=thread')
    ldflags .append('-fsanitize=thread')
if args.mode == 'release':
    cppflags.extend(['-flto', '-fomit-frame-pointer'])
    ldflags .extend(['-flto'])

cppflags += os.getenv('CPPFLAGS', '').split()
cflags   += os.getenv('CFLAGS'  , '').split()
cxxflags += os.getenv('CXXFLAGS', '').split()
ldflags  += os.getenv('LDFLAGS' , '').split()

def git_grep(*args):
    p = subprocess.Popen(['git', 'grep'] + list(args), stdout=subprocess.PIPE)
    stdout, _ = p.communicate()
    if p.returncode and p.returncode != 1:
        sys.exit(p.returncode)
    return [line.strip() for line in stdout.split()]

mains = git_grep('-lw', 'int main', '**.c') + git_grep('-lw', 'int main', '**.cc')

srcs_cc  = set()
srcs_cxx = set()
todo = list(mains)
deps = collections.defaultdict(set)

include = re.compile('#include "(.*)\.h')
while todo:
    src = todo.pop()
    (srcs_cc if src.endswith('.c') else srcs_cxx).add(src)
    for line in open(src):
        m = include.match(line.strip())
        if not m:
            continue
        for dep in [os.path.join(os.path.dirname(src), d)
                    for d in [m.group(1)+'.c', m.group(1)+'.cc']]:
            if not os.path.exists(dep):
                continue
            if dep != src:
                deps[src].add(dep)
            if dep not in srcs_cc and dep not in srcs_cxx:
                todo.append(dep)

def ext(path, new_ext):
    return os.path.splitext(path)[0] + new_ext

def resolve_deps(path):
    link_cxx = path.endswith('.cc')
    objs = {os.path.join('obj', ext(path,'.o'))}
    for dep in deps[path]:
        _objs, _link_cxx = resolve_deps(dep)
        objs.update(_objs)
        link_cxx = link_cxx or _link_cxx
    return objs, link_cxx

with open('build.ninja', 'w') as f:
    f.write(template.format(cc=cc, cxx=cxx,
                            cppflags=' '.join(cppflags),
                            cflags  =' '.join(cflags),
                            cxxflags=' '.join(cxxflags),
                            ldflags =' '.join(ldflags)))
    for src in srcs_cc:
        f.write('build obj/{obj}: cc {src}\n'.format(obj=ext(src,'.o'), src=src))
    for src in srcs_cxx:
        f.write('build obj/{obj}: cxx {src}\n'.format(obj=ext(src,'.o'), src=src))
    for src in mains:
        objs, link_cxx = resolve_deps(src)
        link = 'link_cxx' if link_cxx else 'link_cc'
        f.write('build bin/{exe}: {link} {objs}\n'.format(exe=ext(src,''),
                                                          link=link,
                                                          objs=' '.join(sorted(objs))))
        if '_test' in src:
            f.write('build expected/{exe}: run bin/{exe}\n'.format(exe=ext(src,'')))

rc = subprocess.call(['ninja'] + ninja_args)
os.remove('build.ninja')
sys.exit(rc)
