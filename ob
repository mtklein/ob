#!/usr/bin/env python2.7

import argparse
import collections
import os
import re
import subprocess
import sys

template = '''
builddir = out
rule compile_c
    command     = {cc} -x c {cppflags} {cflags} -MMD -MF $out.d -c $in -o $out
    depfile     = $out.d
    deps        = gcc
    description = compile $out
rule compile_cxx
    command     = {cxx} -x c++ {cppflags} {cxxflags} -MMD -MF $out.d -c $in -o $out
    depfile     = $out.d
    deps        = gcc
    description = compile $out
rule link_c
    command     = {cc} {ldflags} $in -o $out
    description = link $out
rule link_cxx
    command     = {cxx} -lc++ {ldflags} $in -o $out
    description = link $out
rule run
    command     = ./$in > $out
    description = run $in
'''

parser = argparse.ArgumentParser(description='ob, opinionated builder')
for mode in ['debug', 'release', 'ASAN', 'TSAN']:
    parser.add_argument('-'+mode.upper()[0], '--'+mode.lower(),
                        action='store_const', dest='mode', const=mode.lower(), help=mode)
args,ninja_args = parser.parse_known_args()

is_osx = sys.platform == 'darwin'

cc  = os.getenv('CC', 'clang' if is_osx else 'cc')
cxx = os.getenv('CXX', cc)
is_clang = 'clang' in cc and 'clang' in cxx

cppflags = ['-fPIC']
cflags   = ['-std=c11']
cxxflags = ['-std=c++14', '-fno-exceptions', '-fno-rtti']
ldflags  = []

if is_clang:
    cppflags.append('-fcolor-diagnostics')
    if is_osx:
        cppflags.append('-arch x86_64 -arch x86_64h')
        ldflags .append('-arch x86_64 -arch x86_64h')
if args.mode != 'debug':
    cppflags.append('-Os')
if args.mode != 'release':
    cppflags.extend(['-g', '-Werror'])
    cppflags.extend(['-Weverything', '-Wno-padded'] if is_clang else ['-Wall', '-Wextra'])
if args.mode == 'release':
    cppflags.append('-DNDEBUG')
if args.mode == 'asan':
    cppflags.append('-fsanitize=address,undefined')
    ldflags .append('-fsanitize=address,undefined')
if args.mode == 'tsan':
    cppflags.append('-fsanitize=thread')
    ldflags .append('-fsanitize=thread')
if args.mode == 'release':
    cppflags.extend(['-flto', '-fomit-frame-pointer'])
    ldflags .extend(['-flto'])

cppflags += os.getenv('CPPFLAGS', '').split()
cflags   += os.getenv('CFLAGS'  , '').split()
cxxflags += os.getenv('CXXFLAGS', '').split()
ldflags  += os.getenv('LDFLAGS' , '').split()

def git_grep(*args):
    p = subprocess.Popen(['git', 'grep'] + list(args), stdout=subprocess.PIPE)
    stdout, _ = p.communicate()
    if p.returncode and p.returncode != 1:
        sys.exit(p.returncode)
    return [line.strip() for line in stdout.split()]

mains = git_grep('-lw', 'int main', '**.c') + git_grep('-lw', 'int main', '**.cc')

srcs = set()
todo = list(mains)
deps = collections.defaultdict(set)

include = re.compile('#include "(.*)\.h')
while todo:
    src = todo.pop()
    srcs.add(src)
    for line in open(src):
        m = include.match(line.strip())
        if not m:
            continue
        for dep in [os.path.join(os.path.dirname(src), d)
                    for d in [m.group(1)+'.c', m.group(1)+'.cc']]:
            if not os.path.exists(dep):
                continue
            if dep != src:
                deps[src].add(dep)
            if dep not in srcs:
                todo.append(dep)

def ext(path, new_ext):
    return os.path.splitext(path)[0] + new_ext

def resolve_deps(path):
    any_cxx = path.endswith('.cc')
    objs = {os.path.join('out', ext(path,'.o'))}
    for dep in deps[path]:
        _objs, _any_cxx = resolve_deps(dep)
        objs.update(_objs)
        any_cxx = any_cxx or _any_cxx
    return objs, any_cxx

with open('build.ninja', 'w') as f:
    f.write(template.format(cc=cc, cxx=cxx,
                            cppflags=' '.join(cppflags),
                            cflags  =' '.join(cflags),
                            cxxflags=' '.join(cxxflags),
                            ldflags =' '.join(ldflags)))
    for src in srcs:
        rule = 'compile_cxx' if src.endswith('.cc') else 'compile_c'
        f.write('build out/{obj}: {rule} {src}\n'.format(obj=ext(src,'.o'), rule=rule, src=src))
    for src in mains:
        objs, any_cxx = resolve_deps(src)
        exe = os.path.basename(ext(src, ''))
        rule = 'link_cxx' if any_cxx else 'link_c'
        f.write('build out/{exe}: {rule} {objs}\n'.format(exe=exe, rule=rule,
                                                          objs=' '.join(sorted(objs))))
        if '_test' in src:
            f.write('build out/{exe}.log: run out/{exe}\n'.format(exe=exe))

rc = subprocess.call(['ninja'] + ninja_args)
os.remove('build.ninja')
sys.exit(rc)
